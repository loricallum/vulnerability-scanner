// File containing functions that detect vulnerabilities; each function corresponds to one type of vulnerability
const jsonpath = require('jsonpath')
const { JSONPath } = require('jsonpath-plus')

const detectCompilerMajorVersion = (parseTree) => {
  // patterns match outdated compiler version
  const pragmaDirective = jsonpath.query(parseTree, '$.children[?(@.type=="PragmaDirective")]')
  if (pragmaDirective.length !== 1) {
    return { error: 'Smart contract must contain exactly one pragma directive.' }
  }
  const compilerVersionParsed = pragmaDirective[0].value.split('.')
  const compilerMajorVersion = compilerVersionParsed[1]
  if (isNaN(compilerMajorVersion)) {
    return { error: 'Invalid pragma directive.' }
  }
  return parseInt(compilerMajorVersion, 10)
}

module.exports = {
  detectReentrancy: (parseTree, patterns) => {
    const vulnerableFunctionCalls = []
    const vulnerableFuncIndexes = []

    const functionDefinitions = jsonpath.query(parseTree, patterns[0])
    functionDefinitions.forEach((funcDef) => {
      const functionCalls = []
      const assignmentOps = []
      const statements = jsonpath.query(funcDef, patterns[1])[0]
      statements.forEach((statement, index) => {
        // Extracts all function calls from statement
        const statementFunctionCalls = jsonpath.query(statement, patterns[2])
        if (statementFunctionCalls.length > 0) {
          statementFunctionCalls.forEach((functionCall) => {
            if (functionCall.expression.name !== 'require') {
              functionCalls.push({ index, statement })
            }
          })
        } else {
          const statementAssignOps = jsonpath.query(statement, patterns[3])
          if (statementAssignOps) {
            assignmentOps.push({ index, statement })
          }
        }
      })
      functionCalls.forEach((functionCall) => {
        assignmentOps.forEach((assignmentOp) => {
          if (functionCall.index < assignmentOp.index && !(vulnerableFuncIndexes.includes(functionCall.index))) {
            vulnerableFuncIndexes.push(functionCall.index)
            vulnerableFunctionCalls.push(functionCall)
          }
        })
      })
    })
    return vulnerableFunctionCalls
  },

  detectOutdatedCompilerVersion: (parseTree, patterns) => {
    const outdatedPragmaDirective = []
    const pragmaDirective = jsonpath.query(parseTree, patterns[0])
    const compilerMajorVersion = detectCompilerMajorVersion(parseTree)
    if (compilerMajorVersion.error) {
      return [compilerMajorVersion]
    }
    if (compilerMajorVersion < 8) {
      outdatedPragmaDirective.push(pragmaDirective[0])
    }
    return outdatedPragmaDirective
  },

  detectFloatingPragma: (parseTree, patterns) => {
    const floatingPragmaDirective = []
    const pragmaDirective = jsonpath.query(parseTree, patterns[0])
    if (pragmaDirective.length !== 1) {
      return [{ error: 'Smart contract must contain exactly one pragma directive.' }]
    }
    if (pragmaDirective[0].value.includes('^')) {
      floatingPragmaDirective.push(pragmaDirective[0])
    }
    return floatingPragmaDirective
  },

  detectTransferAndSend: (parseTree, patterns) => {
    const transferOrSendCalls = []
    const functionDefinitions = jsonpath.query(parseTree, patterns[0])
    functionDefinitions.forEach((funcDef) => {
      const statements = jsonpath.query(funcDef, patterns[1])[0]
      statements.forEach((statement) => {
        const detectedCalls = jsonpath.query(statement, patterns[2])
        if (detectedCalls.length > 0) {
          transferOrSendCalls.push(statement)
        }
      })
    })
    return transferOrSendCalls
  },

  detectUncheckedCallReturnValue: (parseTree, patterns) => {
    let uncheckedCallReturnValues = []
    let object = parseTree

    for (let i = 0; i < patterns.length; i++) {
      object = JSONPath({ json: object, path: patterns[i], resultType: 'value' })
    }
    uncheckedCallReturnValues = object
    return uncheckedCallReturnValues
  },

  detectTXOrigin: (parseTree, patterns) => {
    const vulnerableStatements = []
    const functionDefinitions = jsonpath.query(parseTree, patterns[0])
    functionDefinitions.forEach((funcDef) => {
      const statements = jsonpath.query(funcDef, patterns[1])[0]
      statements.forEach((statement) => {
        const txOriginStatement = jsonpath.query(statement, patterns[2])
        if (txOriginStatement.length > 0) {
          vulnerableStatements.push(statement)
        }
      })
    })
    return vulnerableStatements
  },

  detectUnderFlow: (parseTree, patterns) => {
    // Solidity compiler versions greater than 0.8.0 protect against underflow
    // If compiler version greater than 0.8.0, no underflow vulnerabilities present
    const compilerMajorVersion = detectCompilerMajorVersion(parseTree)
    if (compilerMajorVersion.error) {
      return compilerMajorVersion
    }
    if (compilerMajorVersion >= 8) {
      return [0, []]
    }
    const detectedPattern = []
    // If any expression is handled in If statement, then it is mentioned in trueBody statement. If it is not, then we can say, it is mentioned outside the If condition where boundary conditions are not handled, it's vulnerability for us. So we will directly push those statements in our detected_pattern array
    const statement = jsonpath.query(parseTree, patterns[0])
    for (let i = 0; i < statement.length; i++) {
      detectedPattern.push(statement[i])
    }

    // Now, we are considering scenario where our expression is mentioned in If statement - expression a -= b, but not handled in If condition
    const ifStatementQuery = jsonpath.query(parseTree, patterns[1])
    for (let i = 0; i < ifStatementQuery.length; i++) {
      const ifStatement = ifStatementQuery[i]
      if (ifStatement.length !== 0) {
        const checkVariableinifstatement = jsonpath.query(ifStatement, patterns[2])

        const checkVariableinifcondition = jsonpath.query(ifStatement, patterns[3])

        if (checkVariableinifstatement.length > 0) {
          if (checkVariableinifcondition.length > 0) {
            if (checkVariableinifstatement[0] !== checkVariableinifcondition[0]) {
              const statementInif = jsonpath.query(ifStatement, patterns[4])
              detectedPattern.push(statementInif)
            }
          } else {
            const statementInif = jsonpath.query(ifStatement, patterns[4])
            detectedPattern.push(statementInif)
          }
        }
      }
    }

    // Now, we are considering scenario where our expression is mentioned in If statement - expression a = a - b, but not handled in If condition
    const ifStatementQuery2 = jsonpath.query(parseTree, patterns[1])
    for (let i = 0; i < ifStatementQuery2.length; i++) {
      const ifStatement = ifStatementQuery2[i]
      if (ifStatement.length !== 0) {
        const checkVariableinifstatement = jsonpath.query(ifStatement, patterns[5])

        const checkVariableinifcondition = jsonpath.query(ifStatement, patterns[3])

        if (checkVariableinifstatement.length > 0) {
          if (checkVariableinifcondition.length > 0) {
            if (checkVariableinifstatement[0] !== checkVariableinifcondition[0]) {
              const statementInif = jsonpath.query(ifStatement, patterns[6])
              detectedPattern.push(statementInif)
            }
          } else {
            const statementInif = jsonpath.query(ifStatement, patterns[6])
            detectedPattern.push(statementInif)
          }
        }
        // console.log(detected_pattern)
      }
    }

    // Now, we are considering scenario where our expression is mentioned in While loop, but not checked in While condition
    const whileStatementQuery = jsonpath.query(parseTree, patterns[7])
    for (let i = 0; i < whileStatementQuery.length; i++) {
      const whileStatement = whileStatementQuery[i]
      if (whileStatement.length !== 0) {
        const checkVariableinwhilestatement = jsonpath.query(whileStatement, patterns[8])
        const checkVariableinwhilecondition = jsonpath.query(whileStatement, patterns[9])

        if ((checkVariableinwhilestatement.length >= 0) && (checkVariableinwhilecondition.length >= 0)) {
          if (checkVariableinwhilestatement[0] !== checkVariableinwhilecondition[0]) {
            const statementInWhile = jsonpath.query(whileStatement, patterns[10])
            detectedPattern.push(statementInWhile)
          }
        }
      }
    }

    // Now, we are considering scenario where our expression is mentioned in For loop, but boundary condition is not checked in For condition
    const forStatementquery = jsonpath.query(parseTree, patterns[11])
    for (let i = 0; i < forStatementquery.length; i++) {
      const forStatement = forStatementquery[i]
      if (forStatement !== 0) {
        const checkVariableinforstatement = jsonpath.query(forStatement, patterns[9])
        const checkVariableinforcondition = jsonpath.query(forStatement, patterns[12])
        if ((checkVariableinforstatement.length >= 0) && (checkVariableinforcondition.length >= 0)) {
          if (checkVariableinforstatement[0] !== checkVariableinforcondition[0]) {
            detectedPattern.push(forStatement)
          }
        }
      }
    }

    // console.log(detected_pattern)
    if (detectedPattern.length > 0) {
      return [1, detectedPattern]
    } else {
      return [0, []]
    }
  },

  detectOverFlow: (parseTree, patterns) => {
    // Solidity compiler versions greater than 0.8.0 protect against overflow
    // If compiler version greater than 0.8.0, no overflow vulnerabilities present
    const compilerMajorVersion = detectCompilerMajorVersion(parseTree)
    if (compilerMajorVersion.error) {
      return compilerMajorVersion
    }
    if (compilerMajorVersion >= 8) {
      return [0, []]
    }
    const detectedPattern = []
    // If any expression is handled in If statement, then it is mentioned in trueBody statement. If it is not, then we can say, it is mentioned outside the If condition where boundary conditions are not handled, it's vulnerability for us. So we will directly push those statements in our detected_pattern array
    const statement = jsonpath.query(parseTree, patterns[0])
    for (let i = 0; i < statement.length; i++) {
      detectedPattern.push(statement[i])
    }

    // Now, we are considering scenario where our expression (a = a + b) is mentioned in If statement, but not handled in If condition
    const ifStatementquery = jsonpath.query(parseTree, patterns[1])
    for (let i = 0; i < ifStatementquery.length; i++) {
      const ifStatement = ifStatementquery[i]
      if (ifStatement.length !== 0) {
        const checkVariableinifstatement = jsonpath.query(ifStatement, patterns[2])
        const checkVariableinifcondition = jsonpath.query(ifStatement, patterns[3])
        const checkVariableinifvariable = jsonpath.query(ifStatement, patterns[4])

        if (checkVariableinifcondition !== 0) {
          if (checkVariableinifstatement.length !== 0 && checkVariableinifvariable !== 0) {
            if (checkVariableinifstatement[0] !== checkVariableinifvariable[0]) {
              const statementInif = jsonpath.query(ifStatement, patterns[5])
              detectedPattern.push(statementInif)
            }
          }
        }
      }
    }

    // Now, we are considering scenario where our expression (a += b) is mentioned in If statement, but not handled in If condition
    const ifStatementquery1 = jsonpath.query(parseTree, patterns[1])
    for (let i = 0; i < ifStatementquery1.length; i++) {
      const ifStatement = ifStatementquery1[i]
      if (ifStatement.length !== 0) {
        const checkVariableinifstatement = jsonpath.query(ifStatement, patterns[6])
        const checkVariableinifcondition = jsonpath.query(ifStatement, patterns[7])
        const checkVariableinifvariable = jsonpath.query(ifStatement, patterns[8])
        if (checkVariableinifstatement.length !== 0 && checkVariableinifvariable !== 0) {
          if (checkVariableinifstatement[0] !== checkVariableinifvariable[0]) {
            const statementInif = jsonpath.query(ifStatement, patterns[9])
            detectedPattern.push(statementInif)
          } else {
            if (checkVariableinifcondition.length === 0) {
              const statementInif = jsonpath.query(ifStatement, patterns[9])
              detectedPattern.push(statementInif)
            }
          }
        }
      }
    }

    // Now, we are considering scenario where our expression is mentioned in While loop, but not checked in While condition
    const whileStatementQuery = jsonpath.query(parseTree, patterns[10])
    for (let i = 0; i < whileStatementQuery.length; i++) {
      const whileStatement = whileStatementQuery[i]
      if (whileStatement.length !== 0) {
        const checkVariableinwhilestatement = jsonpath.query(whileStatement, patterns[11])
        const checkVariableinwhilecondition = jsonpath.query(whileStatement, patterns[7])
        const checkVariableinwhilevariable = jsonpath.query(whileStatement, patterns[12])

        if (checkVariableinwhilestatement.length !== 0 && checkVariableinwhilevariable.length !== 0) {
          if (checkVariableinwhilestatement[0] !== checkVariableinwhilevariable[0]) {
            const statementInwhile = jsonpath.query(whileStatement, patterns[13])
            detectedPattern.push(statementInwhile)
          } else {
            if (checkVariableinwhilecondition === 0) {
              const statementInwhile = jsonpath.query(whileStatement, patterns[13])
              detectedPattern.push(statementInwhile)
            }
          }
        }
      }
    }

    // Now, we are considering scenario where our expression is mentioned in For loop, but boundary condition is not checked in For condition
    const forStatementquery = jsonpath.query(parseTree, patterns[14])
    for (let i = 0; i < forStatementquery.length; i++) {
      const forStatement = forStatementquery[i]
      if (forStatement !== 0) {
        const checkVariableinforstatement = jsonpath.query(forStatement, patterns[7])
        const checkVariableinforvariable = jsonpath.query(forStatement, patterns[12])
        const checkVariableinforcondition = jsonpath.query(forStatement, patterns[15])
        if (checkVariableinforstatement.length !== 0 && checkVariableinforvariable.length !== 0 && checkVariableinforcondition.length !== 0) {
          if (checkVariableinforvariable[0] !== checkVariableinforcondition[0]) {
            detectedPattern.push(forStatement)
          }
        }
      }
    }

    // console.log(detected_pattern)
    if (detectedPattern.length > 0) {
      return [1, detectedPattern]
    } else {
      return [0, []]
    }
  }
}
