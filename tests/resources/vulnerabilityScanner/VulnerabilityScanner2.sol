pragma solidity ^0.5.1;

contract ApartmentRental {

    address payable landlordAddress;

    address payable renterAddress;

    uint256 public apartmentCount = 0;

    modifier onlyLandlord(){
        require(msg.sender == landlordAddress);
        _;
    }

    struct Apartment {
        uint256 number;
        string name;
        uint256 pricePerNight;
        address currentRenter;
        uint256 numNightsRented;
        bool available;
    }

    mapping(uint => Apartment) apartments;

    event SuccessfulTransaction(string apartmentName, uint256 numNights, uint256 amountPaid);

    constructor() public {
        landlordAddress = msg.sender;
    }

    function getApartmentDetails(uint256 _apartmentNum) public view returns (
        address payable landlord,
        uint256 apartmentNumber,
        string memory apartmentName,
        uint256 pricePerNightInEther,
        address currentRenter,
        uint256 numberNightsRented,
        bool isAvailable
    ) {
        landlord = landlordAddress;
        apartmentNumber = apartments[_apartmentNum].number;
        apartmentName = apartments[_apartmentNum].name;
        pricePerNightInEther = apartments[_apartmentNum].pricePerNight;
        currentRenter = apartments[_apartmentNum].currentRenter;
        numberNightsRented = apartments[_apartmentNum].numNightsRented;
        isAvailable = apartments[_apartmentNum].available;
    }

    function setName(uint256 _apartmentNum, string memory _name) public onlyLandlord {
        apartments[_apartmentNum].name = _name;
    }

    function setPrice(uint256 _apartmentNum, uint256 _pricePerNight) public onlyLandlord {
        apartments[_apartmentNum].pricePerNight = _pricePerNight;
    }

    function reserveApartment(uint256 _apartmentNum, address payable rentAddress, uint256 numNightsReserved) internal {
        apartments[_apartmentNum].available = false;
        apartments[_apartmentNum].currentRenter = rentAddress;
        apartments[_apartmentNum].numNightsRented = numNightsReserved;
    }
}