const file = require('../utils/fileUtils')
const parser = require('@solidity-parser/parser')
const db = require('../utils/databaseUtils')
const { vulnerabilityScanner } = require('../vulnerability-scanner')
const assert = require('assert')
const { vulnerabilities } = require('../const/vulnerabilities')

afterAll(async () => await db.closeDbConnection())

describe('Test function that runs and aggregates the results of all vulnerability detectors', () => {
  it('should detect one floating pragma vulnerability and one reentrancy vulnerability', async () => {
    jest.setTimeout(10000)
    const solidityFile = 'tests/resources/vulnerabilityScanner/VulnerabilityScanner1.sol'
    const fileContents = file.readFileContents(solidityFile).toString()
    const parseTree = parser.parse(fileContents)
    await db.establishDbConnection()
    const vulnerabilitiesDetected = await vulnerabilityScanner(parseTree)
    assert.equal(vulnerabilitiesDetected.length, 2)
    assert.equal(vulnerabilitiesDetected[0].vid, vulnerabilities.REENTRANCY)
    assert.equal(vulnerabilitiesDetected[0].object.length, 1)

    assert.equal(vulnerabilitiesDetected[1].vid, vulnerabilities.FLOATING_PRAGMA)
    assert.equal(vulnerabilitiesDetected[1].object.length, 1)
  })

  it('should detect one floating pragma vulnerability and one outdated compiler vulnerability', async () => {
    const solidityFile = 'tests/resources/vulnerabilityScanner/VulnerabilityScanner2.sol'
    const fileContents = file.readFileContents(solidityFile).toString()
    const parseTree = parser.parse(fileContents)
    await db.establishDbConnection()
    const vulnerabilitiesDetected = await vulnerabilityScanner(parseTree)
    assert.equal(vulnerabilitiesDetected.length, 2)
    assert.equal(vulnerabilitiesDetected[0].vid, vulnerabilities.FLOATING_PRAGMA)
    assert.equal(vulnerabilitiesDetected[0].object.length, 1)

    assert.equal(vulnerabilitiesDetected[1].vid, vulnerabilities.OUTDATED_COMPILER_VERSION)
    assert.equal(vulnerabilitiesDetected[1].object.length, 1)
  })

  it('should detect one floating pragma vulnerability, one outdated compiler vulnerability, and one unchecked call return value vulnerability', async () => {
    const solidityFile = 'tests/resources/vulnerabilityScanner/VulnerabilityScanner3.sol'
    const fileContents = file.readFileContents(solidityFile).toString()
    const parseTree = parser.parse(fileContents)
    await db.establishDbConnection()
    const vulnerabilitiesDetected = await vulnerabilityScanner(parseTree)
    assert.equal(vulnerabilitiesDetected.length, 3)
    assert.equal(vulnerabilitiesDetected[0].vid, vulnerabilities.UNCHECKED_CALL_RETURN_VALUE)
    assert.equal(vulnerabilitiesDetected[0].object.length, 1)

    assert.equal(vulnerabilitiesDetected[1].vid, vulnerabilities.FLOATING_PRAGMA)
    assert.equal(vulnerabilitiesDetected[1].object.length, 1)

    assert.equal(vulnerabilitiesDetected[2].vid, vulnerabilities.OUTDATED_COMPILER_VERSION)
    assert.equal(vulnerabilitiesDetected[2].object.length, 1)
  })

  it('should detect three tx.origin vulnerabilities and one hardcoded gas amount vulnerability', async () => {
    const solidityFile = 'tests/resources/vulnerabilityScanner/VulnerabilityScanner4.sol'
    const fileContents = file.readFileContents(solidityFile).toString()
    const parseTree = parser.parse(fileContents)
    await db.establishDbConnection()
    const vulnerabilitiesDetected = await vulnerabilityScanner(parseTree)
    assert.equal(vulnerabilitiesDetected.length, 2)
    assert.equal(vulnerabilitiesDetected[0].vid, vulnerabilities.AUTH_THROUGH_TX_ORIGIN)
    assert.equal(vulnerabilitiesDetected[0].object.length, 3)

    assert.equal(vulnerabilitiesDetected[1].vid, vulnerabilities.HARDCODED_GAS_AMOUNT)
    assert.equal(vulnerabilitiesDetected[1].object.length, 1)
  })

  it('should detect one overflow vulnerability, one underflow vulnerability, one outdated compiler vulnerability, and one reentrancy vulnerability', async () => {
    const solidityFile = 'tests/resources/vulnerabilityScanner/VulnerabilityScanner5.sol'
    const fileContents = file.readFileContents(solidityFile).toString()
    const parseTree = parser.parse(fileContents)
    await db.establishDbConnection()
    const vulnerabilitiesDetected = await vulnerabilityScanner(parseTree)
    assert.equal(vulnerabilitiesDetected.length, 4)

    assert.equal(vulnerabilitiesDetected[0].vid, vulnerabilities.REENTRANCY)
    assert.equal(vulnerabilitiesDetected[0].object.length, 1)

    assert.equal(vulnerabilitiesDetected[1].vid, vulnerabilities.INT_OVERFLOW)
    assert.equal(vulnerabilitiesDetected[1].object.length, 1)

    assert.equal(vulnerabilitiesDetected[2].vid, vulnerabilities.INT_UNDERFLOW)
    assert.equal(vulnerabilitiesDetected[2].object.length, 1)

    assert.equal(vulnerabilitiesDetected[3].vid, vulnerabilities.OUTDATED_COMPILER_VERSION)
    assert.equal(vulnerabilitiesDetected[3].object.length, 1)
  })

  it('should detect all seven of the detectable vulnerability types: ' +
    'two tx.origin vulnerabilities, one floating pragma vulnerability, ' +
    'one hardcoded gas amount vulnerability, one integer overflow vulnerability, ' +
    'one integer underflow vulnerability, one outdated compiler vulnerability, ' +
    'one reentrancy vulnerability, and one unchecked call return value vulnerability', async () => {
    const solidityFile = 'tests/resources/vulnerabilityScanner/VulnerabilityScannerAll.sol'
    const fileContents = file.readFileContents(solidityFile).toString()
    const parseTree = parser.parse(fileContents)
    await db.establishDbConnection()
    const vulnerabilitiesDetected = await vulnerabilityScanner(parseTree)
    assert.equal(vulnerabilitiesDetected.length, 8)

    assert.equal(vulnerabilitiesDetected[0].vid, vulnerabilities.REENTRANCY)
    assert.equal(vulnerabilitiesDetected[0].object.length, 1)

    assert.equal(vulnerabilitiesDetected[1].vid, vulnerabilities.AUTH_THROUGH_TX_ORIGIN)
    assert.equal(vulnerabilitiesDetected[1].object.length, 2)

    assert.equal(vulnerabilitiesDetected[2].vid, vulnerabilities.INT_OVERFLOW)
    assert.equal(vulnerabilitiesDetected[2].object.length, 1)

    assert.equal(vulnerabilitiesDetected[3].vid, vulnerabilities.INT_UNDERFLOW)
    assert.equal(vulnerabilitiesDetected[3].object.length, 1)

    assert.equal(vulnerabilitiesDetected[4].vid, vulnerabilities.UNCHECKED_CALL_RETURN_VALUE)
    assert.equal(vulnerabilitiesDetected[4].object.length, 1)

    assert.equal(vulnerabilitiesDetected[5].vid, vulnerabilities.HARDCODED_GAS_AMOUNT)
    assert.equal(vulnerabilitiesDetected[5].object.length, 1)

    assert.equal(vulnerabilitiesDetected[6].vid, vulnerabilities.FLOATING_PRAGMA)
    assert.equal(vulnerabilitiesDetected[6].object.length, 1)

    assert.equal(vulnerabilitiesDetected[7].vid, vulnerabilities.OUTDATED_COMPILER_VERSION)
    assert.equal(vulnerabilitiesDetected[7].object.length, 1)
  })
})
